<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mho Distance Relay Visualizer</title>
    <link rel="stylesheet" href="tokens.css">
    <style>
        .main-layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: var(--space-lg);
        }

        .controls-panel {
            padding: var(--space-lg);
            background: var(--bg-subtle);
            border-radius: var(--radius-md);
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }

        .section-title {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: var(--space-lg) 0 var(--space-md) 0;
            padding-bottom: var(--space-sm);
            border-bottom: 1px solid var(--bg-hover);
        }

        .section-title:first-child {
            margin-top: 0;
        }

        .input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
        }

        .checkbox-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-sm);
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            font-size: 0.875rem;
        }

        .checkbox-item input {
            margin: 0;
            accent-color: var(--text);
        }

        .zone-phase { color: var(--phase-c); }
        .zone-ground { color: var(--phase-b); }

        .computed-k0 {
            background: var(--bg);
            padding: var(--space-md);
            border-radius: var(--radius-sm);
            margin: var(--space-md) 0;
            font-family: var(--font-mono);
            font-size: 0.875rem;
        }

        .plot-container {
            background: var(--bg-subtle);
            border-radius: var(--radius-md);
            padding: var(--space-lg);
        }

        #canvas {
            cursor: grab;
            width: 100%;
            max-width: 700px;
            background: var(--bg);
            border-radius: var(--radius-sm);
        }

        #canvas:active {
            cursor: grabbing;
        }

        .trip-status {
            margin-top: var(--space-md);
            padding: var(--space-md);
            border-radius: var(--radius-sm);
            font-family: var(--font-mono);
            text-align: center;
        }

        .trip-status.trip {
            background: rgba(255, 69, 58, 0.1);
            border: 1px solid var(--error);
            color: var(--error);
        }

        .trip-status.no-trip {
            background: rgba(48, 209, 88, 0.1);
            border: 1px solid var(--success);
            color: var(--success);
        }

        .copy-btn {
            width: 100%;
            margin-top: var(--space-md);
            padding: var(--space-sm) var(--space-md);
            background: var(--bg-hover);
            border: 1px solid var(--bg-hover);
            border-radius: var(--radius-sm);
            color: var(--text-secondary);
            font-size: 0.875rem;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .copy-btn:hover {
            background: var(--bg);
            border-color: var(--text-secondary);
        }

        @media (max-width: 1000px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            .controls-panel {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <a href="/random/" class="header-back">← Relay Tools</a>
            <span class="header-title">Mho Circles</span>
        </header>

        <h1>Mho Distance Relay Visualizer</h1>
        <p class="tagline">Visualize zone reaches and check trip conditions</p>

        <div class="main-layout">
            <div class="controls-panel">
                <div class="section-title">Line Parameters</div>
                <div class="input-grid">
                    <div class="input-group">
                        <label>Z1 Magnitude (Ω)</label>
                        <input type="number" id="z1mag" value="10" step="0.1">
                    </div>
                    <div class="input-group">
                        <label>Z1 Angle (°)</label>
                        <input type="number" id="lineAngle" value="85">
                    </div>
                    <div class="input-group">
                        <label>Z0 Magnitude (Ω)</label>
                        <input type="number" id="z0mag" value="30" step="0.1">
                    </div>
                    <div class="input-group">
                        <label>Z0 Angle (°)</label>
                        <input type="number" id="z0ang" value="80">
                    </div>
                </div>

                <div class="computed-k0" id="computedK0">
                    Computed k₀: --
                </div>

                <div class="section-title">Relay k₀ Settings</div>
                <div class="input-grid">
                    <div class="input-group">
                        <label>k₀ Magnitude</label>
                        <input type="number" id="k0m" value="0.667" step="0.001">
                    </div>
                    <div class="input-group">
                        <label>k₀ Angle (°)</label>
                        <input type="number" id="k0a" value="-5.4">
                    </div>
                </div>
                <button class="copy-btn" onclick="copyK0()">Copy Computed k₀ to Settings</button>

                <div class="section-title">Phase Mho Reaches (Ω)</div>
                <div class="input-grid">
                    <div class="input-group">
                        <label>Zone 1</label>
                        <input type="number" id="z1p" value="5">
                    </div>
                    <div class="input-group">
                        <label>Zone 2</label>
                        <input type="number" id="z2p" value="10">
                    </div>
                    <div class="input-group">
                        <label>Zone 3</label>
                        <input type="number" id="z3p" value="15">
                    </div>
                    <div class="input-group">
                        <label>Zone 4</label>
                        <input type="number" id="z4p" value="20">
                    </div>
                </div>

                <div class="section-title">Ground Mho Reaches (Ω)</div>
                <div class="input-grid">
                    <div class="input-group">
                        <label>Zone 1</label>
                        <input type="number" id="z1g" value="5">
                    </div>
                    <div class="input-group">
                        <label>Zone 2</label>
                        <input type="number" id="z2g" value="10">
                    </div>
                    <div class="input-group">
                        <label>Zone 3</label>
                        <input type="number" id="z3g" value="15">
                    </div>
                    <div class="input-group">
                        <label>Zone 4</label>
                        <input type="number" id="z4g" value="20">
                    </div>
                </div>

                <div class="section-title">Display Options</div>
                <div class="checkbox-group">
                    <label class="checkbox-item zone-phase"><input type="checkbox" id="showZ1P" checked> Phase Z1</label>
                    <label class="checkbox-item zone-ground"><input type="checkbox" id="showZ1G" checked> Ground Z1</label>
                    <label class="checkbox-item zone-phase"><input type="checkbox" id="showZ2P" checked> Phase Z2</label>
                    <label class="checkbox-item zone-ground"><input type="checkbox" id="showZ2G" checked> Ground Z2</label>
                    <label class="checkbox-item zone-phase"><input type="checkbox" id="showZ3P" checked> Phase Z3</label>
                    <label class="checkbox-item zone-ground"><input type="checkbox" id="showZ3G" checked> Ground Z3</label>
                    <label class="checkbox-item zone-phase"><input type="checkbox" id="showZ4P" checked> Phase Z4</label>
                    <label class="checkbox-item zone-ground"><input type="checkbox" id="showZ4G" checked> Ground Z4</label>
                </div>

                <div class="section-title">Fault Point</div>
                <div class="input-grid">
                    <div class="input-group">
                        <label>Fault Type</label>
                        <select id="faultType">
                            <option value="phase">Phase Fault</option>
                            <option value="ground">Ground Fault</option>
                        </select>
                    </div>
                    <div></div>
                    <div class="input-group">
                        <label>R (Ω)</label>
                        <input type="number" id="faultR" value="3" step="0.1">
                    </div>
                    <div class="input-group">
                        <label>X (Ω)</label>
                        <input type="number" id="faultX" value="6" step="0.1">
                    </div>
                </div>
            </div>

            <div class="plot-container">
                <canvas id="canvas" width="700" height="700"></canvas>
                <div class="trip-status no-trip" id="tripStatus">No trip</div>
            </div>
        </div>

        <div class="drawer-trigger" id="stepToggle">See calculations →</div>
        <div class="step-content" id="stepContent">
            <div class="show-work-content" id="calculations"></div>
        </div>
    </div>

    <script>
        let zoom = 1.0;
        let viewCenterR = 0.0;
        let viewCenterX = 0.0;
        let isDragging = false;
        let dragStartR = 0, dragStartX = 0;
        let dragStartMouseX = 0, dragStartMouseY = 0;

        document.querySelectorAll('input, select').forEach(el => {
            el.addEventListener('change', drawPlot);
            el.addEventListener('input', drawPlot);
        });

        document.getElementById('stepToggle').addEventListener('click', () => {
            document.getElementById('stepContent').classList.toggle('open');
        });

        function copyK0() {
            const z1mag = parseFloat(document.getElementById('z1mag').value);
            const z0mag = parseFloat(document.getElementById('z0mag').value);
            const lineAngleDeg = parseFloat(document.getElementById('lineAngle').value);
            const z0angDeg = parseFloat(document.getElementById('z0ang').value);

            if (isNaN(z1mag) || isNaN(z0mag) || z1mag <= 0 || z0mag <= 0) return;

            const lineAngleRad = lineAngleDeg * Math.PI / 180;
            const z0angRad = z0angDeg * Math.PI / 180;

            const z1_re = z1mag * Math.cos(lineAngleRad);
            const z1_im = z1mag * Math.sin(lineAngleRad);
            const z0_re = z0mag * Math.cos(z0angRad);
            const z0_im = z0mag * Math.sin(z0angRad);

            const z1_mag_sq = z1_re * z1_re + z1_im * z1_im;
            const z0_over_z1_re = (z0_re * z1_re + z0_im * z1_im) / z1_mag_sq;
            const z0_over_z1_im = (z0_im * z1_re - z0_re * z1_im) / z1_mag_sq;

            const k0_re = (z0_over_z1_re - 1) / 3;
            const k0_im = z0_over_z1_im / 3;

            const k0m = Math.sqrt(k0_re * k0_re + k0_im * k0_im);
            const k0a = Math.atan2(k0_im, k0_re) * 180 / Math.PI;

            document.getElementById('k0m').value = k0m.toFixed(3);
            document.getElementById('k0a').value = k0a.toFixed(1);
            drawPlot();
        }

        function getReaches() {
            return {
                p1: parseFloat(document.getElementById('z1p').value),
                p2: parseFloat(document.getElementById('z2p').value),
                p3: parseFloat(document.getElementById('z3p').value),
                p4: parseFloat(document.getElementById('z4p').value),
                g1: parseFloat(document.getElementById('z1g').value),
                g2: parseFloat(document.getElementById('z2g').value),
                g3: parseFloat(document.getElementById('z3g').value),
                g4: parseFloat(document.getElementById('z4g').value)
            };
        }

        function getShows() {
            return {
                p1: document.getElementById('showZ1P').checked,
                p2: document.getElementById('showZ2P').checked,
                p3: document.getElementById('showZ3P').checked,
                p4: document.getElementById('showZ4P').checked,
                g1: document.getElementById('showZ1G').checked,
                g2: document.getElementById('showZ2G').checked,
                g3: document.getElementById('showZ3G').checked,
                g4: document.getElementById('showZ4G').checked
            };
        }

        function drawPlot() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            const lineAngleDeg = parseFloat(document.getElementById('lineAngle').value);
            const lineAngleRad = lineAngleDeg * Math.PI / 180;

            const reaches = getReaches();
            const shows = getShows();

            const faultR = parseFloat(document.getElementById('faultR').value);
            const faultX = parseFloat(document.getElementById('faultX').value);
            const faultType = document.getElementById('faultType').value;

            const z1mag = parseFloat(document.getElementById('z1mag').value);
            const z0mag = parseFloat(document.getElementById('z0mag').value);
            const z0angDeg = parseFloat(document.getElementById('z0ang').value);
            const k0m_set = parseFloat(document.getElementById('k0m').value);
            const k0a_set = parseFloat(document.getElementById('k0a').value);

            let k0_re = 0, k0_im = 0;
            let calcText = '';
            if (!isNaN(z1mag) && !isNaN(z0mag) && z1mag > 0 && z0mag > 0 && !isNaN(z0angDeg)) {
                const z0angRad = z0angDeg * Math.PI / 180;
                const z1_re = z1mag * Math.cos(lineAngleRad);
                const z1_im = z1mag * Math.sin(lineAngleRad);
                const z0_re = z0mag * Math.cos(z0angRad);
                const z0_im = z0mag * Math.sin(z0angRad);

                const z1_mag_sq = z1_re * z1_re + z1_im * z1_im;
                const z0_over_z1_re = (z0_re * z1_re + z0_im * z1_im) / z1_mag_sq;
                const z0_over_z1_im = (z0_im * z1_re - z0_re * z1_im) / z1_mag_sq;

                k0_re = (z0_over_z1_re - 1) / 3;
                k0_im = z0_over_z1_im / 3;

                const k0m = Math.sqrt(k0_re * k0_re + k0_im * k0_im);
                const k0a = Math.atan2(k0_im, k0_re) * 180 / Math.PI;

                document.getElementById('computedK0').innerHTML =
                    `<strong>Computed k₀:</strong> ${k0m.toFixed(4)} ∠ ${k0a.toFixed(2)}°`;

                calcText = `Zero Sequence Compensation Factor k₀
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
k₀ = (Z₀/Z₁ - 1) / 3

Given:
  Z₁ = ${z1mag} ∠ ${lineAngleDeg}° Ω
  Z₀ = ${z0mag} ∠ ${z0angDeg}° Ω

Result:
  k₀ = ${k0m.toFixed(4)} ∠ ${k0a.toFixed(2)}°
`;
            }

            let maxReach = Math.max(...Object.values(reaches)) || 1;
            const baseScale = Math.min(width, height) / (3 * maxReach);
            const scale = baseScale * zoom;
            if (scale === 0) return;

            const minR = viewCenterR - (centerX / scale);
            const maxR = viewCenterR + ((width - centerX) / scale);
            const minX = viewCenterX - ((height - centerY) / scale);
            const maxX = viewCenterX + (centerY / scale);
            const visibleWidth = maxR - minR;

            let gridInterval = Math.pow(10, Math.floor(Math.log10(visibleWidth / 10)));
            if (gridInterval <= 0 || !isFinite(gridInterval)) gridInterval = 1;
            const decimals = gridInterval < 1 ? 1 : 0;

            ctx.strokeStyle = '#1d1d1f';
            ctx.lineWidth = 0.5;

            let gridStart = Math.ceil(minR / gridInterval) * gridInterval;
            for (let r = gridStart; r <= maxR; r += gridInterval) {
                const px = centerX + (r - viewCenterR) * scale;
                ctx.beginPath();
                ctx.moveTo(px, 0);
                ctx.lineTo(px, height);
                ctx.stroke();
            }

            gridStart = Math.ceil(minX / gridInterval) * gridInterval;
            for (let x = gridStart; x <= maxX; x += gridInterval) {
                const py = centerY - (x - viewCenterX) * scale;
                ctx.beginPath();
                ctx.moveTo(0, py);
                ctx.lineTo(width, py);
                ctx.stroke();
            }

            ctx.strokeStyle = '#3a3a3c';
            ctx.lineWidth = 1;
            const axisX = centerX + (0 - viewCenterR) * scale;
            const axisY = centerY - (0 - viewCenterX) * scale;
            ctx.beginPath();
            ctx.moveTo(axisX, 0);
            ctx.lineTo(axisX, height);
            ctx.moveTo(0, axisY);
            ctx.lineTo(width, axisY);
            ctx.stroke();

            ctx.fillStyle = '#86868b';
            ctx.font = '12px -apple-system, sans-serif';
            ctx.fillText('R (Ω)', width - 50, axisY - 10);
            ctx.fillText('X (Ω)', axisX + 10, 20);

            ctx.font = '10px -apple-system, sans-serif';
            gridStart = Math.ceil(minR / gridInterval) * gridInterval;
            for (let r = gridStart; r <= maxR; r += gridInterval) {
                if (Math.abs(r) < gridInterval/10) continue;
                const px = centerX + (r - viewCenterR) * scale;
                ctx.fillText(r.toFixed(decimals), px - 10, axisY + 15);
            }
            gridStart = Math.ceil(minX / gridInterval) * gridInterval;
            for (let x = gridStart; x <= maxX; x += gridInterval) {
                if (Math.abs(x) < gridInterval/10) continue;
                const py = centerY - (x - viewCenterX) * scale;
                ctx.fillText(x.toFixed(decimals), axisX + 5, py + 4);
            }

            function drawMho(reach, color, label, isDashed = false) {
                if (reach <= 0) return;
                const cR = (reach / 2) * Math.cos(lineAngleRad);
                const cX = (reach / 2) * Math.sin(lineAngleRad);
                const rad = reach / 2;

                const cpx = centerX + (cR - viewCenterR) * scale;
                const cpy = centerY - (cX - viewCenterX) * scale;
                const rpx = rad * scale;

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                if (isDashed) ctx.setLineDash([8, 4]);
                else ctx.setLineDash([]);

                ctx.beginPath();
                ctx.arc(cpx, cpy, rpx, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);

                const reachR = reach * Math.cos(lineAngleRad);
                const reachX = reach * Math.sin(lineAngleRad);
                const lx = centerX + (reachR - viewCenterR) * scale;
                const ly = centerY - (reachX - viewCenterX) * scale;
                ctx.fillStyle = color;
                ctx.font = 'bold 11px -apple-system, sans-serif';
                ctx.fillText(label, lx + 8, ly - 8);
            }

            // Phase circles (blue shades)
            if (shows.p1) drawMho(reaches.p1, '#0a84ff', 'P1');
            if (shows.p2) drawMho(reaches.p2, '#409cff', 'P2');
            if (shows.p3) drawMho(reaches.p3, '#70b8ff', 'P3', true);
            if (shows.p4) drawMho(reaches.p4, '#a0d4ff', 'P4', true);

            // Ground circles (green shades)
            if (shows.g1) drawMho(reaches.g1, '#30d158', 'G1');
            if (shows.g2) drawMho(reaches.g2, '#5ee382', 'G2');
            if (shows.g3) drawMho(reaches.g3, '#8cf5ab', 'G3', true);
            if (shows.g4) drawMho(reaches.g4, '#b8ffd0', 'G4', true);

            // Line angle indicator
            const lineLen = maxReach * 1.2;
            const lineEndR = lineLen * Math.cos(lineAngleRad);
            const lineEndX = lineLen * Math.sin(lineAngleRad);
            ctx.strokeStyle = '#ffd60a';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(centerX + (0 - viewCenterR) * scale, centerY - (0 - viewCenterX) * scale);
            ctx.lineTo(centerX + (lineEndR - viewCenterR) * scale, centerY - (lineEndX - viewCenterX) * scale);
            ctx.stroke();
            ctx.setLineDash([]);

            // Fault point
            let plotR = faultR;
            let plotX = faultX;
            let faultLabel = `(${faultR.toFixed(1)}, ${faultX.toFixed(1)})`;

            if (faultType === 'ground' && !isNaN(k0m_set) && !isNaN(k0a_set)) {
                const one_plus_k0t_re = 1 + k0_re;
                const one_plus_k0t_im = k0_im;

                let zapp_re = faultR * one_plus_k0t_re - faultX * one_plus_k0t_im;
                let zapp_im = faultR * one_plus_k0t_im + faultX * one_plus_k0t_re;

                const k0s_rad = k0a_set * Math.PI / 180;
                const k0s_re = k0m_set * Math.cos(k0s_rad);
                const k0s_im = k0m_set * Math.sin(k0s_rad);

                const one_plus_k0s_re = 1 + k0s_re;
                const one_plus_k0s_im = k0s_im;

                let denom = one_plus_k0s_re * one_plus_k0s_re + one_plus_k0s_im * one_plus_k0s_im;
                if (denom === 0) denom = 1e-6;
                plotR = (zapp_re * one_plus_k0s_re + zapp_im * one_plus_k0s_im) / denom;
                plotX = (zapp_im * one_plus_k0s_re - zapp_re * one_plus_k0s_im) / denom;

                faultLabel = `(${faultR.toFixed(1)}, ${faultX.toFixed(1)}) → (${plotR.toFixed(2)}, ${plotX.toFixed(2)})`;
            }

            if (!isNaN(faultR) && !isNaN(faultX)) {
                const fpx = centerX + (plotR - viewCenterR) * scale;
                const fpy = centerY - (plotX - viewCenterX) * scale;

                ctx.fillStyle = '#ff453a';
                ctx.beginPath();
                ctx.arc(fpx, fpy, 6, 0, 2 * Math.PI);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = '11px -apple-system, sans-serif';
                ctx.fillText(faultLabel, fpx + 12, fpy - 8);
            }

            function isInsideMho(reach, r, x) {
                if (reach <= 0) return false;
                const cr = (reach / 2) * Math.cos(lineAngleRad);
                const cx = (reach / 2) * Math.sin(lineAngleRad);
                const dist = Math.sqrt((r - cr) ** 2 + (x - cx) ** 2);
                return dist <= (reach / 2);
            }

            let trippingZones = [];
            if (!isNaN(plotR) && !isNaN(plotX)) {
                const zonesToCheck = faultType === 'phase' ? ['p1', 'p2', 'p3', 'p4'] : ['g1', 'g2', 'g3', 'g4'];
                zonesToCheck.forEach(z => {
                    if (shows[z] && isInsideMho(reaches[z], plotR, plotX)) {
                        trippingZones.push((z[0] === 'p' ? 'Phase ' : 'Ground ') + 'Zone ' + z[1]);
                    }
                });
            }

            const tripStatus = document.getElementById('tripStatus');
            if (trippingZones.length > 0) {
                tripStatus.className = 'trip-status trip';
                tripStatus.textContent = 'TRIP: ' + trippingZones.join(', ');
            } else {
                tripStatus.className = 'trip-status no-trip';
                tripStatus.textContent = 'No trip - Fault outside all enabled zones';
            }

            document.getElementById('calculations').textContent = calcText;
        }

        drawPlot();

        const canvas = document.getElementById('canvas');

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const reaches = getReaches();
            let maxReach = Math.max(...Object.values(reaches)) || 1;
            const baseScale = Math.min(canvas.width, canvas.height) / (3 * maxReach);
            const currentScale = baseScale * zoom;

            const mouseR = viewCenterR + (mx - canvas.width/2) / currentScale;
            const mouseX = viewCenterX + (canvas.height/2 - my) / currentScale;

            const zoomFactor = e.deltaY < 0 ? 1.2 : 1/1.2;
            zoom *= zoomFactor;
            zoom = Math.max(0.1, Math.min(20, zoom));

            viewCenterR = mouseR - (mx - canvas.width/2) / (baseScale * zoom);
            viewCenterX = mouseX - (canvas.height/2 - my) / (baseScale * zoom);

            drawPlot();
        });

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            canvas.style.cursor = 'grabbing';
            const rect = canvas.getBoundingClientRect();
            dragStartMouseX = e.clientX - rect.left;
            dragStartMouseY = e.clientY - rect.top;
            dragStartR = viewCenterR;
            dragStartX = viewCenterX;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const reaches = getReaches();
            let maxReach = Math.max(...Object.values(reaches)) || 1;
            const baseScale = Math.min(canvas.width, canvas.height) / (3 * maxReach);
            const currentScale = baseScale * zoom;

            const deltaX = mx - dragStartMouseX;
            const deltaY = my - dragStartMouseY;

            viewCenterR = dragStartR - deltaX / currentScale;
            viewCenterX = dragStartX + deltaY / currentScale;

            drawPlot();
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });
    </script>
</body>
</html>
